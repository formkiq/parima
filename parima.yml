AWSTemplateFormatVersion: 2010-09-09
Transform: AWS::Serverless-2016-10-31
Description: Parima v1.2 - Launch Your Website using AWS in Minutes (https://github.com/formkiq/parima)

Parameters:

  NotificationEmail:
    Type: String
    Description: Optional. Email address that is sent website update notifications
    Default: ""
  DomainName:
    Type: String
    Description: Optional. Required for custom domain, e.g. www.yourcompany.com
    Default: ""
  WebsiteVersion:
    Type: String
    Description: Required. Version website to deploy
    AllowedPattern: ".+"
    Default: "v1"
  GitRepositoryUrl:
    Type: String
    Description: Optional. Git Repository Url, e.g. https://github.com/YOUR-USERNAME/YOUR-REPOSITORY.git
    Default: ""
  GitBranch:
    Type: String
    Description: Optional. Git Deployment Branch - defaults to 'master'
    Default: ""    
  DeploymentType:
    Type: String
    Description: Optional. Deployment methology to use
    Default: "static"
    AllowedValues: 
      - "static"
      - "Hugo v0.76.3"
Mappings: 
  RegionMap: 
    us-east-1:
      BUCKET: formkiq-distribution-us-east-1-core
    us-east-2:
      BUCKET: formkiq-distribution-us-east-2-core     
    us-west-1:
      BUCKET: formkiq-distribution-us-west-1-core
    us-west-2:
      BUCKET: formkiq-distribution-us-west-2-core
    ca-central-1:
      BUCKET: formkiq-distribution-ca-central-1-core
    af-south-1:
      BUCKET: formkiq-distribution-af-south-1-core
    ap-east-1:
      BUCKET: formkiq-distribution-ap-east-1-core
    ap-south-1:
      BUCKET: formkiq-distribution-ap-south-1-core
    ap-northeast-3:
      BUCKET: formkiq-distribution-ap-northeast-3-core
    ap-northeast-2:
      BUCKET: formkiq-distribution-ap-northeast-2-core
    ap-southeast-1:
      BUCKET: formkiq-distribution-ap-southeast-1-core
    ap-southeast-2:
      BUCKET: formkiq-distribution-ap-southeast-2-core
    ap-northeast-1:
      BUCKET: formkiq-distribution-ap-northeast-1-core
    eu-central-1:
      BUCKET: formkiq-distribution-eu-central-1-core
    eu-west-1:
      BUCKET: formkiq-distribution-eu-west-1-core
    eu-west-2:
      BUCKET: formkiq-distribution-eu-west-2-core
    eu-south-1:
      BUCKET: formkiq-distribution-eu-south-1-core
    eu-west-3:
      BUCKET: formkiq-distribution-eu-west-3-core
    eu-north-1:
      BUCKET: formkiq-distribution-eu-north-1-core
    me-south-1:
      BUCKET: formkiq-distribution-me-south-1-core
    sa-east-1:
      BUCKET: formkiq-distribution-sa-east-1-core
  DeploymentTypeMap:
    "static":
      IMAGE: parima/layers/layer-hugo-0.76.3.zip
    "Hugo-v0.76.3": 
      IMAGE: parima/layers/layer-hugo-0.76.3.zip

Conditions:
  HasCertificate: !Not [ !Equals [ !Ref DomainName, "" ]]
  HasEmail: !Not [ !Equals [ !Ref NotificationEmail, "" ]]
  NoCertificate: !Equals [ !Ref DomainName, "" ]
  StaticDeployment: !Equals [ !Ref DeploymentType, "static" ]

Resources:

  S3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      AccessControl: Private
      Tags:
        - Key: "Application"
          Value: "Parima"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        IgnorePublicAcls: true
        BlockPublicPolicy: true
        RestrictPublicBuckets: true

  S3BucketPolicy:
    Type: "AWS::S3::BucketPolicy"
    Properties: 
      Bucket: !Ref S3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement: 
        - 
          Action: 
            - "s3:GetObject"
          Effect: "Allow"
          Resource: 
            Fn::Join: 
              - ""
              - 
                -  !GetAtt S3Bucket.Arn
                - "/*"
          Principal:
            CanonicalUser: !GetAtt CloudFrontOriginAccessIdentity.S3CanonicalUserId

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Condition: NoCertificate
    DependsOn:
    - DeploymentLambdaResource
    Properties:
      DistributionConfig:
        Origins:
        - DomainName: !GetAtt S3Bucket.RegionalDomainName
          Id: s3origin
          OriginPath: !Join ['', ['/', !GetAtt DeploymentLambdaResource.WebsiteVersion]]
          S3OriginConfig:
            OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}'
        DefaultCacheBehavior:
          Compress: true
          DefaultTTL: 600
          MaxTTL: 600
          MinTTL: 0
          ForwardedValues:
            QueryString: false
          TargetOriginId: s3origin
          ViewerProtocolPolicy: redirect-to-https
        DefaultRootObject: index.html
        Enabled: true
        HttpVersion: http2
        ViewerCertificate:
          MinimumProtocolVersion: TLSv1.1_2016
          CloudFrontDefaultCertificate: true
      Tags:
        - Key: "Application"
          Value: "Parima"

  CloudFrontRoute53:
    Type: AWS::Route53::RecordSet
    Condition: HasCertificate
    Properties:
      Name: !Ref DomainName
      HostedZoneName: !Join ['', [!GetAtt Certificate.HostedZone, '.']]
      Type: A
      AliasTarget:
        HostedZoneId: Z2FDTNDATAQYW2
        DNSName: !GetAtt CloudFrontCertificateDistribution.DomainName

  CloudFrontCertificateDistribution:
    Type: AWS::CloudFront::Distribution
    DependsOn:
    - DeploymentLambdaResource
    - Certificate
    Condition: HasCertificate
    Properties:
      DistributionConfig:
        Origins:
        - DomainName: !GetAtt S3Bucket.RegionalDomainName
          Id: s3origin
          OriginPath: !Join ['', ['/', !GetAtt DeploymentLambdaResource.WebsiteVersion]]
          S3OriginConfig:
            OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CloudFrontOriginAccessIdentity}'
        DefaultCacheBehavior:
          Compress: true
          DefaultTTL: 600
          MaxTTL: 600
          MinTTL: 0
          ForwardedValues:
            QueryString: false
          TargetOriginId: s3origin
          ViewerProtocolPolicy: redirect-to-https
        DefaultRootObject: index.html
        Enabled: true
        HttpVersion: http2
        Aliases:
        - !Ref DomainName
        ViewerCertificate:
          MinimumProtocolVersion: TLSv1.1_2016
          SslSupportMethod: sni-only
          AcmCertificateArn: !GetAtt Certificate.CertificateArn
      Tags:
        - Key: "Application"
          Value: "Parima"

  CloudFrontOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub 'CloudFront for Parima ${S3Bucket}'

  # Create an IAM user with Access Keys to enable automated deployment of the website to this bucket
  PublishUser:
    Type: 'AWS::IAM::User'
    Properties:
      Tags:
      - Key: "Application"
        Value: "Parima"

  PublishGroup:
    Type: AWS::IAM::Group
    Properties:
      Policies:
      - PolicyName: !Sub 'publish-to-${S3Bucket}'
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - s3:ListBucket
            Resource:
            - !Sub 'arn:aws:s3:::${S3Bucket}'            
          - Effect: Allow
            Action:
            - s3:GetObject
            - s3:PutObject
            - s3:ListObjectsV2
            Resource:
            - !Sub 'arn:aws:s3:::${S3Bucket}'
            - !Sub 'arn:aws:s3:::${S3Bucket}/*'

  AddPublishUserToPublishGroup:
    Type: AWS::IAM::UserToGroupAddition
    Properties:
      GroupName: !Ref PublishGroup
      Users:
      - !Ref PublishUser

  PublishCredentials:
    Type: 'AWS::IAM::AccessKey'
    Properties:
      UserName: !Ref PublishUser

  DeploymentLambdaResource:
    Type: Custom::DeploymentLambda
    Properties:
      ServiceToken: !GetAtt DeploymentLambda.Arn
      StackName: !Ref 'AWS::StackName'
      GitRepositoryUrl: !Ref GitRepositoryUrl
      GitBranch: !Ref GitBranch
      DeploymentType: !Ref DeploymentType
      S3Bucket: !Ref S3Bucket
      SyncCommand: !Sub "aws s3 sync . s3://${S3Bucket}/${WebsiteVersion}"
      GithubOAuthUrl: !Sub 'https://oauth.formkiq.com/authorize?redirect_uri=${WebhookApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/webhook'
      WebHookUrl: !Sub 'https://${WebhookApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/webhook'

  Certificate:
    Type: Custom::Certificate
    Condition: HasCertificate
    Properties:
      ServiceToken: !GetAtt CertificateLambda.Arn
      Region: us-east-1
      OutputParameter: Certificate
      DomainName: !Ref DomainName
      StackName: !Ref 'AWS::StackName'

  CertificateLambdaRole:
    Type: AWS::IAM::Role
    Condition: HasCertificate
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
              - lambda.amazonaws.com
          Action:
            - sts:AssumeRole
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - acm:DeleteCertificate
            - acm:RequestCertificate
            - acm:AddTagsToCertificate
            - acm:DescribeCertificate    
            - cloudformation:DescribeStacks
            - route53:ChangeResourceRecordSets
            - route53:ListHostedZonesByName
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            Resource: '*'

  CertificateLambda:
    Type: AWS::Lambda::Function
    Condition: HasCertificate
    Properties:
      Runtime: nodejs12.x
      Timeout: '300'
      Handler: index.handler
      Role: !GetAtt CertificateLambdaRole.Arn
      Tags:
        - Key: "Application"
          Value: "Parima"
      Code:
        ZipFile: |
          const e=require("aws-sdk");var t=new e.ACM,r=new e.Route53,o=new e.CloudFormation;const n=e=>new Promise(t=>setTimeout(t,e));async function a(e,t){var r={StackName:e};return new Promise((e,n)=>{o.describeStacks(r,(function(r,o){if(r)n(r);else{var a="";for(let e of o.Stacks[0].Outputs)e.OutputKey==t&&(a=e.OutputValue);""!=a?e(a):n(a)}}))})}async function i(e,t,r,o){var n=require("https"),a=require("url"),i=JSON.stringify({Status:r,Reason:"See the details in CloudWatch Log Stream: "+t.logStreamName,PhysicalResourceId:e.StackId+"-"+e.LogicalResourceId,StackId:e.StackId,RequestId:e.RequestId,LogicalResourceId:e.LogicalResourceId,Data:o}),s=a.parse(e.ResponseURL),c={hostname:s.hostname,port:443,path:s.path,method:"PUT",headers:{"content-type":"","content-length":i.length}};return new Promise((function(e,t){var r=n.request(c,t=>{t.setEncoding("utf8");let r="";t.on("data",e=>{r+=e}),t.on("end",()=>{e([r,t.statusCode,t.headers])})}).on("error",t=>{JSON.stringify(t);e([{message:"Unable to send message"},502,null])}).on("timeout",()=>{e([{message:"Request has timed out"},502,null])});r.write(i),r.end()}))}module.exports.handler=async(o,s)=>{if(console.log(JSON.stringify(o)),null!=o.RequestType){let c=o.ResourceProperties.Region;if(null!=c&&(t=new e.ACM({region:c}),console.log("using region: "+c)),"Create"===o.RequestType){let e=o.ResourceProperties.DomainName,a=e.substring(e.indexOf(".")+1);return async function(e,r){var o={DomainName:r,DomainValidationOptions:[{DomainName:r,ValidationDomain:e}],SubjectAlternativeNames:["*."+r],Tags:[{Key:"Application",Value:"Parima"}],ValidationMethod:"DNS"};return t.requestCertificate(o).promise()}(a,e).then(e=>(console.log("adding certificate verification DNS entries"),async function e(o,a,i=10,s=1e4){let c=await async function(e){return new Promise((t,o)=>{var n={DNSName:e};r.listHostedZonesByName(n,(function(e,r){e?o(e):t(r.HostedZones[0].Id)}))})}(o);console.log("using hosted zone "+c);try{let e=await async function(e){return t.describeCertificate({CertificateArn:e}).promise()}(a);return await async function(e,t){var o=[];for(let a of t.Certificate.DomainValidationOptions)if(a.ResourceRecord&&a.ResourceRecord.Name){var n={ChangeBatch:{Changes:[{Action:"UPSERT",ResourceRecordSet:{Name:a.ResourceRecord.Name,ResourceRecords:[{Value:a.ResourceRecord.Value}],TTL:60,Type:a.ResourceRecord.Type}}]},HostedZoneId:e};o.push(r.changeResourceRecordSets(n).promise())}return Promise.all(o)}(c,e),a}catch(t){return await n(s),0===i?Promise.reject("Maximum retries exceeded!"):e(o,a,--i,s)}}(a,e.CertificateArn))).then(e=>(console.log("waiting DNS to be updated so certificate can be validated"),async function(e){return t.waitFor("certificateValidated",{CertificateArn:e}).promise()}(e))).then(e=>(console.log("certificate has been validated"),i(o,s,"SUCCESS",{HostedZone:a,CertificateArn:e.Certificate.CertificateArn}))).catch(e=>(console.log(e),i(o,s,"FAILED")))}if("Delete"===o.RequestType){return a(o.ResourceProperties.StackName,o.ResourceProperties.OutputParameter).then(e=>async function e(r,o=30,a=1e4){try{return await async function(e){return console.log("deleting certificate "+e),t.deleteCertificate({CertificateArn:e}).promise()}(r)}catch(t){return await n(a),0===o?Promise.reject("Maximum retries exceeded!"):e(r,--o,a)}}(e)).then(e=>i(o,s,"SUCCESS",{})).catch(e=>(console.log(e),i(o,s,"FAILED")))}if("Update"===o.RequestType){let e=o.ResourceProperties.StackName,t=o.ResourceProperties.OutputParameter,r=o.ResourceProperties.DomainName,n=r.substring(r.indexOf(".")+1);return a(e,t).then(e=>i(o,s,"SUCCESS",{HostedZone:n,CertificateArn:e}))}return i(o,s,"FAILED")}};

  LayerDeployment:
    Type: AWS::Serverless::LayerVersion
    Properties:
      Description: Lambda Layer containing Deployment build binary
      ContentUri: 
        Bucket: !FindInMap [RegionMap, !Ref "AWS::Region", BUCKET]
        Key: !FindInMap [DeploymentTypeMap, !Ref DeploymentType, IMAGE]

  LayerGit:
    Type: AWS::Serverless::LayerVersion
    Properties:
      Description: Lambda Layer containing Git binary
      ContentUri: 
        Bucket: !FindInMap [RegionMap, !Ref "AWS::Region", BUCKET]
        Key: "parima/layers/layer-git-2.28.0.zip"

  DeploymentLambda:
    Type: AWS::Serverless::Function
    Properties:
      Runtime: nodejs12.x
      Timeout: 900
      MemorySize: 512
      Handler: index.handler
      Role: !GetAtt DeploymentLambdaRole.Arn
      Layers: !If [StaticDeployment, [!Ref LayerGit], [!Ref LayerDeployment, !Ref LayerGit]]
      Tags:
        Application: "Parima"
      Environment:
        Variables:
          STACK_NAME: !Ref 'AWS::StackName'
      Events:
        WebhookGet:
          Type: HttpApi
          Properties:
            ApiId: !Ref WebhookApi
            Path: /webhook
            Method: get        
        WebhookPost:
          Type: HttpApi
          Properties:
            ApiId: !Ref WebhookApi
            Path: /webhook
            Method: post
      CodeUri:
        Bucket: !FindInMap [RegionMap, !Ref "AWS::Region", BUCKET]
        Key: "parima/v1.2/deployment.zip"
  
  WebhookApi:
    Type: AWS::Serverless::HttpApi
    Properties:
      Tags:
        Application: "Parima"

  DeploymentLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
              - lambda.amazonaws.com
          Action:
            - sts:AssumeRole
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - s3:GetObject
            - s3:PutObject
            - s3:ListObjectsV2
            Resource:
            - !Sub 'arn:aws:s3:::${S3Bucket}/*'
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            - cloudformation:DescribeStacks
            - cloudformation:UpdateStack
            - iam:GetRole
            - lambda:UpdateFunctionConfiguration
            - iam:PassRole
            - cloudfront:GetDistribution
            - cloudfront:UpdateDistribution
            Resource: '*'
          - Effect: Allow
            Action:
            - ssm:GetParameter
            - ssm:PutParameter
            Resource:
            - !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/formkiq/parima/*"

  VerifyEmailIdentity:
    Type: Custom::VerifyEmailIdentity
    Condition: HasEmail
    Properties:
      ServiceToken: !GetAtt VerifyEmailIdentityLambda.Arn
      Email: !Ref NotificationEmail

  VerifyEmailIdentityLambda:
    Type: AWS::Lambda::Function
    Condition: HasEmail
    Properties:
      Runtime: nodejs12.x
      Timeout: '300'
      Handler: index.handler
      Role: !GetAtt VerifyEmailIdentityLambdaRole.Arn
      Tags:
        - Key: "Application"
          Value: "Parima"
      Code:
        ZipFile: |
          var e=new(require("aws-sdk").SES);async function t(e,t,r,s){var n=require("https"),o=require("url"),a=JSON.stringify({Status:r,Reason:"See the details in CloudWatch Log Stream: "+t.logStreamName,PhysicalResourceId:e.StackId+"-"+e.LogicalResourceId,StackId:e.StackId,RequestId:e.RequestId,LogicalResourceId:e.LogicalResourceId,Data:s}),l=o.parse(e.ResponseURL),i={hostname:l.hostname,port:443,path:l.path,method:"PUT",headers:{"content-type":"","content-length":a.length}};return new Promise((function(e,t){var r=n.request(i,t=>{t.setEncoding("utf8");let r="";t.on("data",e=>{r+=e}),t.on("end",()=>{e([r,t.statusCode,t.headers])})}).on("error",t=>{JSON.stringify(t);e([{message:"Unable to send message"},502,null])}).on("timeout",()=>{e([{message:"Request has timed out"},502,null])});r.write(a),r.end()}))}module.exports.handler=async(r,s)=>{console.log(JSON.stringify(r));var n=null,o=null,a=r.RequestType;return null!=r.ResourceProperties&&(n=r.ResourceProperties.Email),null!=r.OldResourceProperties&&(o=r.OldResourceProperties.Email),"Delete"===a&&(o=r.ResourceProperties.Email,n=null),async function(t){return null!=t?e.deleteIdentity({Identity:t}).promise():Promise.resolve("")}(o).then(t=>async function(t){return null!=t?e.verifyEmailIdentity({EmailAddress:t}).promise():Promise.resolve("")}(n)).then(()=>t(r,s,"SUCCESS",{})).catch(e=>(console.log(e),t(r,s,"FAILED")))};

  VerifyEmailIdentityLambdaRole:
    Type: AWS::IAM::Role
    Condition: HasEmail
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
              - lambda.amazonaws.com
          Action:
            - sts:AssumeRole
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents              
            - ses:DeleteIdentity
            - ses:VerifyEmailIdentity
            Resource: '*'

Outputs:
  Certificate:
    Condition: HasCertificate
    Description: 'Certificate'
    Value: !GetAtt Certificate.CertificateArn
  AccessKeyId:
    Description: 'S3 Access Key'
    Value: !Ref PublishCredentials
  AccessKeySecret:
    Description: 'S3 Secret Key'
    Value: !GetAtt PublishCredentials.SecretAccessKey
  WebsiteUrl:
    Description: 'Website Url'
    Value: !If [HasCertificate, !Sub "https://${DomainName}", !Sub "https://${CloudFrontDistribution.DomainName}"]
  S3Bucket:
    Description: 'S3 Bucket'
    Value: !Ref S3Bucket
  SyncCommand:
    Description: 'Deploy local directory to Website'
    Value: !Sub "aws s3 sync . s3://${S3Bucket}/${WebsiteVersion}"
  InvalidateCache:
    Description: 'Invalidate Website Cache'
    Value: !If [HasCertificate, !Sub "aws cloudfront create-invalidation --distribution-id ${CloudFrontCertificateDistribution} --paths \"/*\"", !Sub "aws cloudfront create-invalidation --distribution-id ${CloudFrontDistribution} --paths \"/*\""]
  WebHookUrl:
    Description: 'Git Deployment Web Hook'
    Value: !Sub 'https://${WebhookApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/webhook'
  GithubOAuthUrl:
    Description: 'Give Parima access to private Git Repository'
    Value: !Sub 'https://oauth.formkiq.com/authorize?redirect_uri=${WebhookApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/webhook'
  DeploymentType:
    Description: Deployment methology to use
    Value: !Ref DeploymentType
  CloudFrontDistributionId:
    Description: 'CloudFront Distribution Id'
    Value: !If [HasCertificate, !Ref CloudFrontCertificateDistribution, !Ref CloudFrontDistribution]